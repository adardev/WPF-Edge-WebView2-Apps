{"version":3,"file":"vendors-node_modules_tanstack_react-virtual_dist_esm_index_js-xxxxxxxxxxxx.js","mappings":"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","sources":["node_modules/@tanstack/virtual-core/dist/esm/utils.js","node_modules/@tanstack/virtual-core/dist/esm/index.js","node_modules/@tanstack/react-virtual/dist/esm/index.js"],"sourcesContent":["function memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  function memoizedFunction() {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%câ± ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) <= 1;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\nexport {\n  approxEqual,\n  debounce,\n  memo,\n  notUndefined\n};\n//# sourceMappingURL=utils.js.map\n","import { debounce, memo, notUndefined, approxEqual } from \"./utils.js\";\nconst getRect = (element) => {\n  const { offsetWidth, offsetHeight } = element;\n  return { width: offsetWidth, height: offsetHeight };\n};\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(getRect(element));\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(getRect(element));\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : debounce(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return element[instance.options.horizontal ? \"offsetWidth\" : \"offsetHeight\"];\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.scrollToIndexTimeoutId = null;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = memo(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = memo(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = memo(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = memo(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = memo(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if (process.env.NODE_ENV !== \"production\" && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = memo(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return notUndefined(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => notUndefined(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n      const maxOffset = this.getTotalSize() - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.cancelScrollToIndex = () => {\n      if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n        this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n        this.scrollToIndexTimeoutId = null;\n      }\n    };\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);\n      if (!offsetAndAlign) return;\n      const [offset, align] = offsetAndAlign;\n      this._scrollToOffset(offset, { adjustments: void 0, behavior });\n      if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n        this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n          this.scrollToIndexTimeoutId = null;\n          const elementInDOM = this.elementsCache.has(\n            this.options.getItemKey(index)\n          );\n          if (elementInDOM) {\n            const [latestOffset] = notUndefined(\n              this.getOffsetForIndex(index, align)\n            );\n            const currentScrollOffset = this.getScrollOffset();\n            if (!approxEqual(latestOffset, currentScrollOffset)) {\n              this.scrollToIndex(index, { align, behavior });\n            }\n          } else {\n            this.scrollToIndex(index, { align, behavior });\n          }\n        });\n      }\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      this.cancelScrollToIndex();\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\nexport {\n  Virtualizer,\n  approxEqual,\n  debounce,\n  defaultKeyExtractor,\n  defaultRangeExtractor,\n  elementScroll,\n  measureElement,\n  memo,\n  notUndefined,\n  observeElementOffset,\n  observeElementRect,\n  observeWindowOffset,\n  observeWindowRect,\n  windowScroll\n};\n//# sourceMappingURL=index.js.map\n","import * as React from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { Virtualizer, elementScroll, observeElementOffset, observeElementRect, windowScroll, observeWindowOffset, observeWindowRect } from \"@tanstack/virtual-core\";\nexport * from \"@tanstack/virtual-core\";\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction useVirtualizerBase(options) {\n  const rerender = React.useReducer(() => ({}), {})[1];\n  const resolvedOptions = {\n    ...options,\n    onChange: (instance2, sync) => {\n      var _a;\n      if (sync) {\n        flushSync(rerender);\n      } else {\n        rerender();\n      }\n      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n    }\n  };\n  const [instance] = React.useState(\n    () => new Virtualizer(resolvedOptions)\n  );\n  instance.setOptions(resolvedOptions);\n  useIsomorphicLayoutEffect(() => {\n    return instance._didMount();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate();\n  });\n  return instance;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase({\n    observeElementRect,\n    observeElementOffset,\n    scrollToFn: elementScroll,\n    ...options\n  });\n}\nfunction useWindowVirtualizer(options) {\n  return useVirtualizerBase({\n    getScrollElement: () => typeof document !== \"undefined\" ? window : null,\n    observeElementRect: observeWindowRect,\n    observeElementOffset: observeWindowOffset,\n    scrollToFn: windowScroll,\n    initialOffset: () => typeof document !== \"undefined\" ? window.scrollY : 0,\n    ...options\n  });\n}\nexport {\n  useVirtualizer,\n  useWindowVirtualizer\n};\n//# sourceMappingURL=index.js.map\n"],"names":["memo","getDeps","fn","opts","result","deps","initialDeps","memoizedFunction","_a","_b","_c","_d","depTime","resultTime","key","debug","call","Date","now","newDeps","length","some","dep","index","depEndTime","Math","round","resultEndTime","resultFpsPercentage","pad","str","num","String","console","info","max","min","onChange","updateDeps","notUndefined","value","msg","approxEqual","a","b","abs","targetWindow","ms","timeoutId","args","clearTimeout","setTimeout","apply","getRect","offsetWidth","offsetHeight","element","width","height","defaultKeyExtractor","defaultRangeExtractor","start","range","startIndex","overscan","end","endIndex","count","arr","i","push","observeElementRect","instance","cb","scrollElement","handler","rect","ResizeObserver","observer","run","entry","entries","borderBoxSize","box","inlineSize","blockSize","options","useAnimationFrameWithResizeObserver","requestAnimationFrame","observe","unobserve","addEventListenerOptions","passive","supportsScrollend","window","observeElementOffset","offset","fallback","useScrollendEvent","isScrollingResetDelay","createHandler","horizontal","isRtl","isScrolling","endHandler","addEventListener","registerScrollendEvent","removeEventListener","measureElement","elementScroll","adjustments","behavior","scrollTo","Virtualizer","unsubs","scrollToIndexTimeoutId","measurementsCache","itemSizeCache","Map","pendingMeasuredCacheIndexes","scrollRect","scrollOffset","scrollDirection","scrollAdjustments","elementsCache","_ro","get","forEach","_measureElement","target","disconnect","setOptions","Object","opts2","initialOffset","paddingStart","paddingEnd","scrollPaddingStart","scrollPaddingEnd","getItemKey","rangeExtractor","initialRect","scrollMargin","gap","indexAttribute","initialMeasurementsCache","lanes","enabled","notify","sync","maybeNotify","calculateRange","cleanup","filter","Boolean","d","_didMount","_willUpdate","getScrollElement","ownerDocument","defaultView","cached","_scrollToOffset","getScrollOffset","getSize","getFurthestMeasurement","measurements","furthestMeasurementsFound","furthestMeasurements","m","measurement","has","lane","previousFurthestMeasurement","set","size","Array","from","values","sort","getMeasurementOptions","getMeasurements","clear","item","slice","furthestMeasurement","measuredSize","estimateSize","outerSize","lastIndex","findNearestBinarySearch","endPerLane","fill","pos","startPerLane","getVirtualIndexes","indexFromElement","attributeName","indexStr","node","getAttribute","parseInt","warn","prevNode","isConnected","resizeItem","delta","shouldAdjustScrollPositionOnItemSizeChange","delete","getVirtualItems","indexes","virtualItems","k","len","getVirtualItemForOffset","getOffsetForAlignment","toOffset","align","itemSize","getTotalSize","getOffsetForIndex","isDynamicMode","cancelScrollToIndex","scrollToOffset","scrollToIndex","initialAlign","offsetAndAlign","latestOffset","scrollBy","endByLane","val","scrollToFn","measure","low","high","getCurrentValue","middle","currentValue","useIsomorphicLayoutEffect","document","useVirtualizer","useVirtualizerBase","rerender","resolvedOptions","instance2","flushSync"],"sourceRoot":""}