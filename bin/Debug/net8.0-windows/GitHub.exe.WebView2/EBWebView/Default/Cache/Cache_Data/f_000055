{"version":3,"file":"vendors-node_modules_tanstack_query-core_build_modern_queryObserver_js-node_modules_tanstack_-defd52-xxxxxxxxxxxx.js","mappings":"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","sources":["node_modules/@tanstack/query-core/build/modern/queryObserver.js","node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js","node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js","node_modules/@tanstack/react-query/build/modern/isRestoring.js","node_modules/@tanstack/react-query/build/modern/suspense.js","node_modules/@tanstack/react-query/build/modern/useBaseQuery.js","node_modules/@tanstack/react-query/build/modern/utils.js"],"sourcesContent":["// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  resolveEnabled,\n  resolveStaleTime,\n  shallowEqualObjects,\n  timeUntilStale\n} from \"./utils.js\";\nvar QueryObserver = class extends Subscribable {\n  constructor(client, options) {\n    super();\n    this.options = options;\n    this.#client = client;\n    this.#selectError = null;\n    this.#currentThenable = pendingThenable();\n    if (!this.options.experimental_prefetchInRender) {\n      this.#currentThenable.reject(\n        new Error(\"experimental_prefetchInRender feature flag is not enabled\")\n      );\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  #client;\n  #currentQuery = void 0;\n  #currentQueryInitialState = void 0;\n  #currentResult = void 0;\n  #currentResultState;\n  #currentResultOptions;\n  #currentThenable;\n  #selectError;\n  #selectFn;\n  #selectResult;\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData;\n  #staleTimeoutId;\n  #refetchIntervalId;\n  #currentRefetchInterval;\n  #trackedProps = /* @__PURE__ */ new Set();\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this);\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch();\n      } else {\n        this.updateResult();\n      }\n      this.#updateTimers();\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect\n    );\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus\n    );\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#clearStaleTimeout();\n    this.#clearRefetchInterval();\n    this.#currentQuery.removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = this.#currentQuery;\n    this.options = this.#client.defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== \"boolean\") {\n      throw new Error(\n        \"Expected enabled to be a boolean or a callback that returns a boolean\"\n      );\n    }\n    this.#updateQuery();\n    this.#currentQuery.setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: this.#currentQuery,\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(\n      this.#currentQuery,\n      prevQuery,\n      this.options,\n      prevOptions\n    )) {\n      this.#executeFetch();\n    }\n    this.updateResult();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {\n      this.#updateStaleTimeout();\n    }\n    const nextRefetchInterval = this.#computeRefetchInterval();\n    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {\n      this.#updateRefetchInterval(nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = this.#client.getQueryCache().build(this.#client, options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      this.#currentResult = result;\n      this.#currentResultOptions = this.options;\n      this.#currentResultState = this.#currentQuery.state;\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  trackResult(result, onPropTracked) {\n    const trackedResult = {};\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.trackProp(key);\n          onPropTracked?.(key);\n          return result[key];\n        }\n      });\n    });\n    return trackedResult;\n  }\n  trackProp(key) {\n    this.#trackedProps.add(key);\n  }\n  getCurrentQuery() {\n    return this.#currentQuery;\n  }\n  refetch({ ...options } = {}) {\n    return this.fetch({\n      ...options\n    });\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = this.#client.defaultQueryOptions(options);\n    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true\n    }).then(() => {\n      this.updateResult();\n      return this.#currentResult;\n    });\n  }\n  #executeFetch(fetchOptions) {\n    this.#updateQuery();\n    let promise = this.#currentQuery.fetch(\n      this.options,\n      fetchOptions\n    );\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop);\n    }\n    return promise;\n  }\n  #updateStaleTimeout() {\n    this.#clearStaleTimeout();\n    const staleTime = resolveStaleTime(\n      this.options.staleTime,\n      this.#currentQuery\n    );\n    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {\n      return;\n    }\n    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);\n    const timeout = time + 1;\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult();\n      }\n    }, timeout);\n  }\n  #computeRefetchInterval() {\n    return (typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;\n  }\n  #updateRefetchInterval(nextInterval) {\n    this.#clearRefetchInterval();\n    this.#currentRefetchInterval = nextInterval;\n    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {\n      return;\n    }\n    this.#refetchIntervalId = setInterval(() => {\n      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n        this.#executeFetch();\n      }\n    }, this.#currentRefetchInterval);\n  }\n  #updateTimers() {\n    this.#updateStaleTimeout();\n    this.#updateRefetchInterval(this.#computeRefetchInterval());\n  }\n  #clearStaleTimeout() {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId);\n      this.#staleTimeoutId = void 0;\n    }\n  }\n  #clearRefetchInterval() {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId);\n      this.#refetchIntervalId = void 0;\n    }\n  }\n  createResult(query, options) {\n    const prevQuery = this.#currentQuery;\n    const prevOptions = this.options;\n    const prevResult = this.#currentResult;\n    const prevResultState = this.#currentResultState;\n    const prevResultOptions = this.#currentResultOptions;\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;\n    const { state } = query;\n    let newState = { ...state };\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = {\n          ...newState,\n          ...fetchState(state.data, query.options)\n        };\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let { error, errorUpdatedAt, status } = newState;\n    if (options.select && newState.data !== void 0) {\n      if (prevResult && newState.data === prevResultState?.data && options.select === this.#selectFn) {\n        data = this.#selectResult;\n      } else {\n        try {\n          this.#selectFn = options.select;\n          data = options.select(newState.data);\n          data = replaceData(prevResult?.data, data, options);\n          this.#selectResult = data;\n          this.#selectError = null;\n        } catch (selectError) {\n          this.#selectError = selectError;\n        }\n      }\n    } else {\n      data = newState.data;\n    }\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {\n        placeholderData = prevResult.data;\n      } else {\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData(\n          this.#lastQueryWithDefinedData?.state.data,\n          this.#lastQueryWithDefinedData\n        ) : options.placeholderData;\n        if (options.select && placeholderData !== void 0) {\n          try {\n            placeholderData = options.select(placeholderData);\n            this.#selectError = null;\n          } catch (selectError) {\n            this.#selectError = selectError;\n          }\n        }\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(\n          prevResult?.data,\n          placeholderData,\n          options\n        );\n        isPlaceholderData = true;\n      }\n    }\n    if (this.#selectError) {\n      error = this.#selectError;\n      data = this.#selectResult;\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: this.#currentThenable\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = (thenable) => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = this.#currentThenable = nextResult.promise = pendingThenable();\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = this.#currentThenable;\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = this.#currentResult;\n    const nextResult = this.createResult(this.#currentQuery, this.options);\n    this.#currentResultState = this.#currentQuery.state;\n    this.#currentResultOptions = this.options;\n    if (this.#currentResultState.data !== void 0) {\n      this.#lastQueryWithDefinedData = this.#currentQuery;\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    this.#currentResult = nextResult;\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const { notifyOnChangeProps } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !this.#trackedProps.size) {\n        return true;\n      }\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps\n      );\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key;\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    this.#notify({ listeners: shouldNotifyListeners() });\n  }\n  #updateQuery() {\n    const query = this.#client.getQueryCache().build(this.#client, this.options);\n    if (query === this.#currentQuery) {\n      return;\n    }\n    const prevQuery = this.#currentQuery;\n    this.#currentQuery = query;\n    this.#currentQueryInitialState = query.state;\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this);\n      query.addObserver(this);\n    }\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      this.#updateTimers();\n    }\n  }\n  #notify(notifyOptions) {\n    notifyManager.batch(() => {\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult);\n        });\n      }\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: \"observerResultsUpdated\"\n      });\n    });\n  }\n};\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false) {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport {\n  QueryObserver\n};\n//# sourceMappingURL=queryObserver.js.map","\"use client\";\n\n// src/QueryErrorResetBoundary.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createValue() {\n  let isReset = false;\n  return {\n    clearReset: () => {\n      isReset = false;\n    },\n    reset: () => {\n      isReset = true;\n    },\n    isReset: () => {\n      return isReset;\n    }\n  };\n}\nvar QueryErrorResetBoundaryContext = React.createContext(createValue());\nvar useQueryErrorResetBoundary = () => React.useContext(QueryErrorResetBoundaryContext);\nvar QueryErrorResetBoundary = ({\n  children\n}) => {\n  const [value] = React.useState(() => createValue());\n  return /* @__PURE__ */ jsx(QueryErrorResetBoundaryContext.Provider, { value, children: typeof children === \"function\" ? children(value) : children });\n};\nexport {\n  QueryErrorResetBoundary,\n  useQueryErrorResetBoundary\n};\n//# sourceMappingURL=QueryErrorResetBoundary.js.map","\"use client\";\n\n// src/errorBoundaryUtils.ts\nimport * as React from \"react\";\nimport { shouldThrowError } from \"./utils.js\";\nvar ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {\n  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {\n    if (!errorResetBoundary.isReset()) {\n      options.retryOnMount = false;\n    }\n  }\n};\nvar useClearResetErrorBoundary = (errorResetBoundary) => {\n  React.useEffect(() => {\n    errorResetBoundary.clearReset();\n  }, [errorResetBoundary]);\n};\nvar getHasError = ({\n  result,\n  errorResetBoundary,\n  throwOnError,\n  query,\n  suspense\n}) => {\n  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));\n};\nexport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n};\n//# sourceMappingURL=errorBoundaryUtils.js.map","\"use client\";\n\n// src/isRestoring.ts\nimport * as React from \"react\";\nvar IsRestoringContext = React.createContext(false);\nvar useIsRestoring = () => React.useContext(IsRestoringContext);\nvar IsRestoringProvider = IsRestoringContext.Provider;\nexport {\n  IsRestoringProvider,\n  useIsRestoring\n};\n//# sourceMappingURL=isRestoring.js.map","// src/suspense.ts\nvar defaultThrowOnError = (_error, query) => query.state.data === void 0;\nvar ensureSuspenseTimers = (defaultedOptions) => {\n  const originalStaleTime = defaultedOptions.staleTime;\n  if (defaultedOptions.suspense) {\n    defaultedOptions.staleTime = typeof originalStaleTime === \"function\" ? (...args) => Math.max(originalStaleTime(...args), 1e3) : Math.max(originalStaleTime ?? 1e3, 1e3);\n    if (typeof defaultedOptions.gcTime === \"number\") {\n      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);\n    }\n  }\n};\nvar willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;\nvar shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;\nvar fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {\n  errorResetBoundary.clearReset();\n});\nexport {\n  defaultThrowOnError,\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n};\n//# sourceMappingURL=suspense.js.map","\"use client\";\n\n// src/useBaseQuery.ts\nimport * as React from \"react\";\nimport { isServer, notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport { useIsRestoring } from \"./isRestoring.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nimport { noop } from \"./utils.js\";\nfunction useBaseQuery(options, Observer, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (typeof options !== \"object\" || Array.isArray(options)) {\n      throw new Error(\n        'Bad argument type. Starting with v5, only the \"Object\" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'\n      );\n    }\n  }\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedOptions = client.defaultQueryOptions(options);\n  client.getDefaultOptions().queries?._experimental_beforeQuery?.(\n    defaultedOptions\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!defaultedOptions.queryFn) {\n      console.error(\n        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`\n      );\n    }\n  }\n  defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n  ensureSuspenseTimers(defaultedOptions);\n  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);\n  useClearResetErrorBoundary(errorResetBoundary);\n  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);\n  const [observer] = React.useState(\n    () => new Observer(\n      client,\n      defaultedOptions\n    )\n  );\n  const result = observer.getOptimisticResult(defaultedOptions);\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => {\n        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop;\n        observer.updateResult();\n        return unsubscribe;\n      },\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setOptions(defaultedOptions);\n  }, [defaultedOptions, observer]);\n  if (shouldSuspend(defaultedOptions, result)) {\n    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);\n  }\n  if (getHasError({\n    result,\n    errorResetBoundary,\n    throwOnError: defaultedOptions.throwOnError,\n    query: client.getQueryCache().get(defaultedOptions.queryHash),\n    suspense: defaultedOptions.suspense\n  })) {\n    throw result.error;\n  }\n  ;\n  client.getDefaultOptions().queries?._experimental_afterQuery?.(\n    defaultedOptions,\n    result\n  );\n  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {\n    const promise = isNewCacheEntry ? (\n      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted\n      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)\n    ) : (\n      // subscribe to the \"cache promise\" so that we can finalize the currentThenable once data comes in\n      client.getQueryCache().get(defaultedOptions.queryHash)?.promise\n    );\n    promise?.catch(noop).finally(() => {\n      observer.updateResult();\n    });\n  }\n  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;\n}\nexport {\n  useBaseQuery\n};\n//# sourceMappingURL=useBaseQuery.js.map","// src/utils.ts\nfunction shouldThrowError(throwError, params) {\n  if (typeof throwError === \"function\") {\n    return throwError(...params);\n  }\n  return !!throwError;\n}\nfunction noop() {\n}\nexport {\n  noop,\n  shouldThrowError\n};\n//# sourceMappingURL=utils.js.map"],"names":["QueryObserver","client","options","experimental_prefetchInRender","reject","bindMethods","setOptions","Set","refetch","bind","onSubscribe","listeners","size","addObserver","shouldFetchOnMount","updateResult","onUnsubscribe","hasListeners","destroy","shouldFetchOnReconnect","shouldFetchOn","refetchOnReconnect","shouldFetchOnWindowFocus","refetchOnWindowFocus","removeObserver","prevOptions","prevQuery","defaultQueryOptions","enabled","_defaulted","getQueryCache","notify","type","query","observer","mounted","shouldFetchOptionally","staleTime","nextRefetchInterval","getOptimisticResult","optimisticResult","build","result","createResult","getCurrentResult","state","trackResult","onPropTracked","trackedResult","Object","keys","forEach","defineProperty","key","configurable","enumerable","get","trackProp","add","getCurrentQuery","fetch","fetchOptimistic","defaultedOptions","then","fetchOptions","cancelRefetch","promise","throwOnError","catch","isStale","time","dataUpdatedAt","setTimeout","refetchInterval","nextInterval","setInterval","refetchIntervalInBackground","isFocused","clearTimeout","clearInterval","data","prevResult","prevResultState","prevResultOptions","queryInitialState","queryChange","newState","isPlaceholderData","_optimisticResults","fetchOnMount","fetchOptionally","fetchStatus","error","errorUpdatedAt","status","select","selectError","placeholderData","Date","now","isFetching","isPending","isError","isLoading","hasData","isSuccess","isInitialLoading","failureCount","fetchFailureCount","failureReason","fetchFailureReason","errorUpdateCount","isFetched","dataUpdateCount","isFetchedAfterMount","isRefetching","isLoadingError","isPaused","isRefetchError","finalizeThenableIfPossible","nextResult","thenable","resolve","recreateThenable","prevThenable","queryHash","value","reason","shouldNotifyListeners","notifyOnChangeProps","notifyOnChangePropsValue","includedProps","some","changed","has","onQueryUpdate","notifyOptions","batch","listener","retryOnMount","refetchOnMount","field","suspense","isStaleByTime","createValue","isReset","clearReset","reset","QueryErrorResetBoundaryContext","useQueryErrorResetBoundary","QueryErrorResetBoundary","children","jsx","Provider","ensurePreventErrorBoundaryRetry","errorResetBoundary","useClearResetErrorBoundary","getHasError","IsRestoringContext","useIsRestoring","IsRestoringProvider","defaultThrowOnError","_error","ensureSuspenseTimers","originalStaleTime","args","Math","max","gcTime","willFetch","isRestoring","shouldSuspend","useBaseQuery","Observer","queryClient","getDefaultOptions","queries","_experimental_beforeQuery","isNewCacheEntry","shouldSubscribe","subscribed","unsubscribe","subscribe","batchCalls","onStoreChange","_experimental_afterQuery","finally","shouldThrowError","throwError","params","noop"],"sourceRoot":""}